# Гайд по оформлению Блупринтов в Unreal Engine

Гайд по оформлению Блупринтов (визуальный язык программирования) в Unreal Engine.

## Наименования

Используйте [PascalCase](https://techterms.com/definition/pascalcase) для наименования всего в Блупринтах, включая переменные, функции, делегаты и прочее.

Названия ДОЛЖНЫ ВСЕГДА точно отражать то, что они означают, аже если для этого придется назвать переменную каким-то длинным именем. Это нормально иногда называть переменные именами, типа "CurrentAngleBetweenCameraAndChar".
Do not use meaningless names or too short names, like "Temp", "Var" or "X".

Названия обязательно на английском языке.

### Названия переменных

Названия переменных должны отражать то, что в них хранится

Например:

```plain
Kills
ObjectLocation
AbleToUseObject
```

### Названия функций

Названия функций должны соответсвовать тому, что функция делает.

Всегда начинайте с глагола при названии функции

Например:

```plain
FindItemInInventory
GetSpeed
CalculateMovementVector
HideOptionScreenOnInteractionDestroy
```

### Названия диспатчеров

Наименования диспатчеров должно начинаться с префикса "On" и так же описывать то, что произошло по этому событию.

Например:

```plain
OnDeath
OnItemAdded
OnGameEnded
```

## Макросы

Макросы никогда не используются. 

Их можно использовать лишь в очень редких случаях, когда нужно сделать переиспользуемую логику с контролем последовательности. Во всех остальных случаях используется функция или просто копипастится участок небольшой кода.

## Функции и События

Почти вся логика должна быть внутри функций. Это правило создано для того, что бы лучше организовывать вашу логику. Если вы используете функции для всего, вся ваша логика будет разделена по отдельным значимым блокам и вы сможете легко найти её в сбоку на панеле "Blueprints" в виде удобного списка.
Если вы будете делать всю вашу логику в EventGraph (основном графе), то рано или поздно ваша логика разрастется и превратится в хаос, по которому сложно будет что-то найти.

Функции так же имеют следующие преимущества перед событиями:

- Локальные переменные (Временные переменные, чье значение хранится только во время выполнения функции)
- Параметры функции можно получить в виде локальной переменной (В поиске Get*название параметра* в контекстном меню)
- Функции могут иметь возвращаемые параметры
- Последовательность внутри функции можно явно прервать используя ReturnNode
- Функции могут быть чистыми (Вызов вне прямой последовательности)
- Функции могут быть приватными (Вы не сможете вызвать функцию вне данного блупринта)
- Функции могут быть константными (Предотвращает возможность отредактировать переменные или состояние объекта разработчиком. Стоит использовать вместе с Pure)

Так же стоит и стандартные события конвертировать в функции, в том числе и те, что перезаписываются в наследниках. Таким образом и эти события вы увидете сбоку в списке, а так же получите многие преимущества функций.

![Blueprints event convert to function](/img/Functions_EventToFunc.png)

Вы по прежнему можете использовать события там, где невозможно использовать функции (Экспоузнутые события диспатчеров, РПЦ функции), или там, где нужно явно отобразить последовательность логики, которая работает за счет делегатов.

## Биндинг диспатчеров

Диспатчеры можно так же биндить и на функции, и это предпочтительнее. Используйте "CreateEvent" ноду что бы создать биндинг.

![Blueprints function dispatcher binding](/img/Functions_Binding.png)

## Возвращающие ноды

Используйте "ReturnNode" для прерывания логики и выхода из функции там, где это нужно. Не создавайте переменных, что бы выйти из функции позже. Это часто используется вместе с функцией ForLoop, когда нужно выйти из функции при нахождении какого-либо элемента, вместо использования ForLoopWithBreak.

Неправильно:
![Blueprints function return Wrong](/img/Functions_LoopReturn_Wrong.png)
Ok:
![Blueprints function return Ok](/img/Functions_LoopReturn_OK.png)
Эта логика чище и не использует лишних переменных.

## Параметры и переменные

Используйте геттеры для получения значений из параметров. Не тяните коннекторы через весь граф.

Тем не менее, можно использовать коннекторы, когда целевая нода находится рядом с началом функции.

![Blueprints parameters Wrong](/img/Functions_Params_Wrong.png)
![Blueprints parameters Ok](/img/Functions_Params_OK.png)

Используйте "L\_" для локальных переменных. Так вы всегда сможете определить, является ли переменная локальной или пренадлежит всему блупринту.

## Pure и Impure функции

В Блупринтах у нас есть возможность создать два типа функций: Pure(чистая) and Impure. По умолчанию, все функции создаются не чистыми, что означает, что у неё будут контакты вызова и её нужно явно подставть в вашу логику. Чистая функция наоборотне имеет контактов вызова и используется для произведения расчетов для параметров обычных функций.

![Blueprint Pure and Impure functions](/img/Functions_PureImpure.png)

Есть простое правило, когда стоит использовать Чистую функцию. Если ваша функция не используется для изменения состояния объекта или изменения переменных, а просто делает какие-то расчеты для того, что бы вернуть значение, то должна использоваться Pure функция.
Очень часто можно определить необходимость в Чистой функции по её имени. Если название начинается с "Get", "Find", "Calculate", "Is" или похожим глаголом, то функция должна быть чистой.

Обратите внимание, что вызов Чистой функции происходит на каждый вызов обычной. Это значит, что одна Pure функция будет вызвана столько раз, с скольки обычным функция она присоеденена. Будьте осторожны!

## Последовательность

### Branch

Даже учитывая то, что в коде это не является хорошей практикой, вы можете использовать только False для продолжения последовательности. В Блупринтах это часто куда более читабельно и удобно, чем добавлять ноду "Not" перед коннектором условия. Использование "Бранча" с "Not" тоже является приемлимым вариантом.

![Blueprints Branch](/img/Flow_Branch.png)

### Ноды контроля последовательности

Поскольку весь код должен быть внутри функций, некоторые ноды из категории "Flow Control" использовать не получится. Речь о тех, которые запоминают состояние внутри себя (FlipFlop, DoN, Gate и тд) или асинхронные (Delay, RetDelay, и тд).

В большинстве случаях Delay так же не стоит использовать. Предпочитайте таймеры (SetTimer), которые вызывают функции через определенное время. Это так же имеет следующие преимущества:

- Вы можете остановить таймер до его окончания. Используйте функцию TimerHandle -> ClearAndInvalidateTimer
- Вы можете зациклить таймер, что бы он вызывал функцию с переодичностью.
- Таймеры работают как внутри функций, так и внутри Графа.
- Вы можете в реальном времени определять то, какая функция будет вызвана по истечению времени (При использовании SetTimerByFunctionName)

Вы можете использовать Delay в косметических Блупринтах, когда это просто более удобно чем Timer.
Вы можете использовать Delay(0) что бы пропустить один кадр там, где это необходимо. Это может быть полезно, например, когда вам нужно подождать, пока все Actor компоненты инициализируются, что бы начать полноценную работу в другом компоненте, чья инициализация зависит от других (BeginPlay в компоненте может вызываться раньше, чем BeginPlay в других).

### Валидация

Валидация используется для проверки переменных-указателей(синий цвет переменнных) на то, что они ссылаются на существующий объект.

Стоит использовать валидирующую ноду переменной для определения последовательности в зависимости от содержимого.
Вы можете превратить обычную "Get" ноду переменной в валидирующую, нажав ПКМ и выбрав Convert To Validated Get в контестном меню;

При валидации сразу после установки переменной или выходнового значения из функций, используйте IsValid ноду.

![Blueprints validation](/img/Flow_Validation.png)

## Выравнивание и общий вид

Главное правило - делать как можно меньше пересечений соеденений путям выравнивания, кеширования значений и использования "Reroute Node", которые позволяют обвести соеденения сбоку от других нод.

Если вам нужно использовать значение в разных местах, стоит закешировать это значение в локальную переменную и использовать его через Get ноду. Тоже самое, если вам нужно использовать результат функции через несколько нод.
Не ведите соеденения через весь граф!

![Blueprints cache result](/img/Functions_Cache.png)

Выравнивайте ноды относительно друг друга, что бы логику было проще прочесть и все выглядело аккуратнее.

![Blueprints nodes align](/img/Look_Align.png)

Для выравнивания, выделете ноды, которые вы ходите выравнить между собой и нажмите горячую клавишу, которые вы можете найти нажав ПКМ по ноде и выбав Node Align в контекстном меню.

## Комментарии

Вы должны комментировать ту логику, чья последовательность не очевидна или не ясно присутсвие конкретных участков. Комментарии должны отвечать на вопрос "Почему". Не тратьте время на написание коментариев, которые объясняют, что делает ваш код, так как это итак должно быть понятно при чтении последовательности.

Вы так же можете записывать разные мысли, которые помогут другим разработчикам, или вам в будущем, понять логику работы отдельного участка.

В комментариях используйте основной язык, на котором говорит ваша команда, если он использует латинницу. В другом случае предпочтите английские комментарии, так как другой формат символов может повлиять на сборку проекта.

Учтите, что вы можете комментировать как участки последовательности, так и отдельные ноды.

В комментарии вы можете добавлять префиксы, что бы в будущем можно было легко найти проблемные места используя глобальный поиск.

BUG - В последовательности имеется известный баг, который в будущем стоит пофиксить.
TODO - В последовательности есть место, которое стоит дописать, переписать или или исправить.

Цвета коментариев не обязательны, используйте их по усмотрению вашего лида или руководства.

## Прочее

### Таймеры

Предпочитайте ставить таймеры через "SetTimerByEvent" а не "SetTimerByFunctionName". Данный тип проверит биндинг на функцию во время компиляции, так что у вас не будет возможности сделать ошибку в названии.
Единственная причина, по которой стоит использовать "SetTimerByFunctionName", когда вам нужно в реальном времени менять вызываемую функцию.

![Blueprints timer by event](/img/Other_Timers.png)
